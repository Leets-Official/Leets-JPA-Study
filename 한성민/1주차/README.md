# 1장 _ JPA 소개
- JPA : 자바 진영에서 만든 ORM 기술 표준

### SQL 직접 다룰 때 발생하는 문제점

- 반복 코드 생성 (CRUD용 SQL을 반복해서 작성해야하는 비생산적인 과정을 수행)
- 진정한 의미의 계층 분할 어려움
- 엔티티 신뢰할 수 없음
- SQL에 의존적인 개발을 하게됨

### JPA를 이용한 문제 해결

- 객체를 데이터베이스에 저장하고 관리할 때 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용한다.
<hr/>

### 패러다임의 불일치
객체지향 프로그래밍은 추상화, 상속, 캡슐화, 정보은닉, 다형성 등 객체지향 언어가 가진 장점들을 사용할 수 있다.

객체를 생성하여 저장하려면 직렬화하는 방법과 관계형 데이터베이스에 저장하는 방법이 있는데 직렬화된 객체를 검색하기 어렵기 때문에
현실적으로 관계형 데이터베이스에 저장해야한다. 

하지만 객체지향에서 말하는 위의 장점과 관계형 데이터베이스가 지향하는 목적이 다르기 때문에 객체 구조를 테이블 구조에 저장하는 데 한계가 있다.
> 이를 객체와 관계형 데이터베이스의 패러다임 불일치라고 한다.

1. 상속

객체는 상속 기능을 가지지만 테이블은 상속 기능이 없다.

데이터베이스 모델링에서 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사하게 설계할 수 있다.

``` 
abstract class Item {
    Long id;
    String name;
    int price;
}

class Album extends Item {
    String artist;
}

class Movie extends Item {
    String director;
    String actor;
}
```
만약 Item 이라는 상위 클래스가 있고 이를 상속 받는 Album과 Movie 클래스가 있다고 하자.

Album 객체를 저장하려면 이 객체를 분해해서 두 SQL로 만들어야 한다. Movie 객체도 마찬가지다.
```
// Album 객체 저장
insert into ITEM ...
insert into ALBUM ...

// Movie 객체 저장
insert into ITEM ...
insert into MOVIE ...
```

JPA가 아닌 JDBC API를 사용한다면 부모 객체에서 부모 데이터만 꺼내서 ITEM용 INSERT SQL을 만들고 자식 객체에서
자식 데이터를 만들어서 Album용 INSERT SQL을 만들어야 한다. 만약 상속받는 클래스가 많아진다면 작성할 코드량은 엄청나게 많아진다.

JPA를 사용하면 패러다임 불일치 문제를 해결해준다.

```
// JPA를 사용한 Album 객체 저장
jpa.persist(album); 
```
이 과정 하나로 

```
insert into ITEM ...
insert into ALBUM ...
```
JPA는 다음 SQL을 실행해준다. 

2. 연관관계

객체는 참조를 사용하여 객체를 조회한다. 그러나 테이블은 외래 키와 조인을 사용해서 연관된 테이블을 조회한다.

만약 Team 객체와 Member 객체가 있고 Member 필드에 Team 객체를 참조한다고 가정해보자.

만약 테이블을 기준으로 객체를 모델링 하면,

```
class Member {
    String id;
    String username;
    
    Long teamId; // TEAM_ID FK
}

class Team {
    Long id;
    String name;
}
```
만약 Member를 이용해 연관된 Team 객체를 찾으려면
```
Team team = member.getTeam();
```
으로 찾을 수 있지만 여기선 teamId를 FK로 갖고 있어 객체지향적인 방법인 참조를 사용하여 조회할 수 없다.

만약 객체지향 모델링을 한다면,
```
class Member {
    String id;
    String username;
    
    Team team; // 참조를 통한 연관관계
}

class Team {
    Long id;
    String name;
}
```
연관된 Team의 참조를 보관하기 때문에 
```
Team team = member.getTeam();
```
회원을 통해 팀을 조회할 수 있게 된다.

이 과정을 JPA를 이용한다면 연관관계와 관련된 패러다임 불일치 문제를 해결할 수 있다.
```
member.setTeam(team); // 회원과 팀 연관관계 설정
jpa.persist(member); // 회원과 연관관계를 함께 저장
```
개발자는 회원과 팀 관계 설정 후 회원 객체를 저장하면 JPA에서 참조를 외래 키로 변환해서 전달한다.

3. 객체 그래프 탐색

객체 그래프 탐색 : 객체에서 참조를 사용해서 연관된 객체를 찾는 과정

만약 SQL을 직접 다루면 자유롭게 객체 그래프를 탐색하지 못하고 SQL에 의존되어 그래프를 탐색하게 된다.
하지만 JPA를 사용하면 연관관계 설정을 통해 객체를 신뢰하고 마음껏 조회할 수 있기 때문에 객체 그래프 탐색을 자유롭게 할 수 있다.

4. 동일성 비교
```
Member member1 = memberDAO.getMember(1L);
Member member2 = memberDAO.getMember(1L);

member1 == member2; // false
```
만약 JPA를 사용하지 않을 경우, MemberDAO.getMember()를 호출할 때 마다 new Member()로 인스턴스를 새로 생성하기 때문에 참조값이 다르다.

하지만 JPA를 사용하면 같은 객체가 조회되는 것을 보장하기 때문에 같은 memberId를 조회하면 동일성 비교에 성공하게 된다.
<hr>

### 그래서 JPA는 뭐야?
* 자바 진영의 ORM(Object-Relational-Mapping) 기술 표준
* 자바 ORM 기술에 대한 API 표준 명세
* 애플리케이션과 JDBC 사이에서 동작

### 그럼 ORM은 뭐야?
* 객체와 관계형 데이터베이스를 매핑
* 위에 기술한 객체와 테이블의 패러다임 불일치 문제를 개발자 대신 해결

=> 객체 측면에서는 정교한 객체 모델링을 할 수 있고, 관계형 DB에서는 데이터베이스에 맞도록 모델링 하면 된다.

=> 둘을 어떻게 매핑해야하는지 매핑 방법만 ORM 프레임워크에 알려주면 된다.

<hr>

# 3장 _ 영속성 관리

### 엔티티 매니저 팩토리 
- 엔티티 매니저를 만드는 공장
- 공장을 만드는 비용은 상당히 크다. -> 한 개의 엔티티 매니저 팩토리를 만들어서 전체 애플리케이션에서 공유
- 여러 스레드가 동시에 접근해도 안전 -> 서로 다른 스레드 간에 공유 가능

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("#{name}");
```

### 엔티티 매니저
```
EntityManager em = emf.createEntityManager();
```
- 여러 스레드가 동시에 접근하면 동시성 문제 발생 -> 스레드 간에 절대 공유 금지
<hr>

## 영속성 컨텍스트

> 엔티티를 영구 저장하는 환경

영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어 진다.
엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

### 엔티티 생명주기
- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태 (영속성 컨텍스트에 의해 관리된다는 의미)
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 (영속성 컨텍스트가 관리하지 않는 상태)
- 삭제(removed) : 삭제된 상태

### 특징
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기 때문에 식별자 값이 필수적이다.
- 영속성 컨텍스트에 엔티티를 저장하면 JPA는 트랜잭션을 커밋하는 순간 DB에 반영한다. (플러시)
- 영속성 컨텍스트가 엔티티를 관리할 때의 장점
  * 1차캐시 : 영속성 컨텍스트 내부의 캐시
    * 영속성 컨텍스트 내 영속 상태인 엔티티가 있다면 이후 조회시 DB에서 조회하는 것이 아닌 1차 캐시에서 조회한다.
  * 동일성 보장
    * find를 통해 영속 상태 엔티티를 여러개 조회해서 동일성(==)을 비교해도 참(True)을 반환한다. (실제 인스턴스 동일)
  * 트랜잭션을 지원하는 쓰기 지연
    * 쓰기 지연 SQL 저장소에 쿼리를 저장해두고 트랜잭션 커밋 시 DB에 쿼리를 보낸다.
  * 변경 감지 (Dirty Checking)
    * 엔티티의 변경사항을 DB에 자동으로 반영하는 기능 
    * 영속성 컨텍스트에 보관된 엔티티와 플러시 시점의 엔티티를 비교해서 엔티티를 수정한다.
  * 지연 로딩

### 플러시 : 영속성 컨텍스트의 변경 내용을 DB에 반영
플러시 방법
1. em.flush() 직접 호출
2. 트랜잭션 커밋 시 플러시 자동 호출
3. JPQL 실행 시 플러시 자동 호출

### 병합 : merge()
- 영속 상태가 아닌 엔티티를 새로운 영속 상태로 반환
- 영속 상태가 아닌 엔티티가 영속 상태로 변경되는 것이 아닌 새로운 영속 상태의 엔티티가 되는 것이다.

