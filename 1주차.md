## 1장 JPA 소개
<hr>

1. SQL을 직접 다룰때 문제점
    1. 등록, 수정, 삭제, 조회 문장을 반복해서 작성하므로 비생산적이라는 단점이 있음
    2. 객체 - 관계형 데이터 베이스 간 차이를 줄이기 위해서 많은 SQL문을 작성해야됨
    3. JPA ORM 프레임워크의 개념

       객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해줌

2. JPA ORM 프레임워크의 개념

   객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해줌

3. JPA의 장점
    1. 위에서 말했던 반복적인 SQL을 알아서 처리해줘서 개발자는 어떤 SQL이 실행될지만 생각하면됨
    2. 객체 중심으로 개발하므로 생산성과 유지보수가 좋아지고 텍스트 작성이 편리해짐
    3. JPA는 상속, 연관관계, 객체 그래프 탐색. 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.
    4. JPA를 사용하면 로컬 개발 환경은 H2, 개발이나 상용 환경은 오라클이나 MySQL 데이터베이스를 사용할 수 있다. 따라서 각 벤더마다 독립성을 보장할 수 있다
4. JPA의 기능
    1. 저장기능 :
       jpa.persist (member); //저장
       persistO 메서드는 객체를 데이터베이스에 저장하는 역할을 하는데, 이 메소드를 호출하면 JPA가 객체와 매핑정보를 보고 INSERT SQL을 생성해서 데이터베이스 에 전달해준다.
    2. 조회 기능 :
       String memberld = "hellold";
       Member member = jpa.find (Member. class,memberld) ; //조회
       find() 메소드는 객체 하나를 데이터베이스에서 조회해준다. JPA는 객체와 매핑정보를 보고 SELECT SQL을 생성 후, 데이터베이스에 전달, 그 결과로 Member 객체를 생성해서 반환한다.
    3. 수정 기능 :
       Member member = jpa. find (Member. classr memberld);
       member. setName ( H이름변경” ) //수정
       JPA는 별도의 수정을 지원하지않고, 대신에 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 데이터베이스에 UPDATE SQL이 전달되는 구조이다. 따라서 간단하게 수정 기능을 수행할 수 있다
    4. 연관된 객체 조회 :
       Member member = jpa.find (Member. class, memberld) ;
       Team team = member.getTeam () ; //연관된 객체 조회
       JPA는 연관된 객체를 사용하는 시점에 SELECT SQL을 실행한다. 따라서 연관된 객체 조회가 편리해진다
5. 패러다임의 불일치 : 위에서 말했던 객체지향에서 말하는 장점과 관계형 데이터베이스가 가지는 장점이 다르기 때문에, 둘의 기능과 표현 방법 또한 다르다. 이것을 패러다임의 불일치라고 한다

   해결방법 1 : 상속 : 패러다임 불일치의 해결 방법으로 자바컬렉션에 객체를 저장하듯이 JPA에 객체를 저장하는 방법임

    ```java
    abstract class Item {
    Long id;
    String name;
    int price;
    }
    class Album extends Item {
    String artist;
    }
    class Movie extends Item {
    String director;
    String actor;
    }
    ```

   위 객체모델 코드를 예시로 들면,

   Album 객체를 저장하려면 이 객체를 분해해서 다음 두 SQL을 만들어야 한다.
   ```java
   INSERT INTO ITEM ...
   INSERT INTO ALBUM ...
   ```
   Movie 객체도 이런식으로 만들어줘야한다
   ```java
   INSERT INTO ITEM ...
   INSERT INTO MOVIE ...
   ```
   단 JPA에서는 자바 컬렉션에 객체 저장하듯이
   ```java
   jpa.persist(album);
   ```
   이 코드로 pesist 메서드를 활용하여 간단하게 객체를 저장할 수 있다.

   저장한 Album 객체를 조회하고싶다면 위에 설명한 find() 메소드를 사용해서 객체를 조회하면 된다
   ```java
   String albumld = "idlOO";
   Album album = jpa.find (Album, class, albumld);
   ```
   해결방법 2 : 연관관계
   객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된
   객체를 조회한다. 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를
   가지고 조인을 사용해서 연관된 테이블을 조회한다.

    ```java
    member. setTeam (team); //회원과 팀 연관관계 설정
    jpa.persist (member); //회원과 연관관계 함께 저장
    Member member = jpa.find(Member.class, memberId);
    Team team = member.getTeam(); 
    ```

   위 코드를 활용하여 개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하여주고, JPA는 team의 참조를 외래 키로 변환해서 INSERT SQL을 데이터베이스에 전달한다.

6. JPA의 개념 : 자바진영의 ORM 기술 표준을 말하며 애플리케이션과 JDBC 사이에서 동작한다
7. ORM의 개념 : ORM(object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻으로 ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다. 개발자는 INSERT SQL을 직접 작성하지 않아도 객체를 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장해주면 된다.
<hr>
