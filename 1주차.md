## 1장 JPA 소개
<hr>

1. SQL을 직접 다룰때 문제점
    1. 등록, 수정, 삭제, 조회 문장을 반복해서 작성하므로 비생산적이라는 단점이 있음
    2. 객체 - 관계형 데이터 베이스 간 차이를 줄이기 위해서 많은 SQL문을 작성해야됨
    3. JPA ORM 프레임워크의 개념

       객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해줌

2. JPA ORM 프레임워크의 개념

   객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해줌

3. JPA의 장점
    1. 위에서 말했던 반복적인 SQL을 알아서 처리해줘서 개발자는 어떤 SQL이 실행될지만 생각하면됨
    2. 객체 중심으로 개발하므로 생산성과 유지보수가 좋아지고 텍스트 작성이 편리해짐
    3. JPA는 상속, 연관관계, 객체 그래프 탐색. 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.
    4. JPA를 사용하면 로컬 개발 환경은 H2, 개발이나 상용 환경은 오라클이나 MySQL 데이터베이스를 사용할 수 있다. 따라서 각 벤더마다 독립성을 보장할 수 있다
4. JPA의 기능
    1. 저장기능 :
       jpa.persist (member); //저장
       persistO 메서드는 객체를 데이터베이스에 저장하는 역할을 하는데, 이 메소드를 호출하면 JPA가 객체와 매핑정보를 보고 INSERT SQL을 생성해서 데이터베이스 에 전달해준다.
    2. 조회 기능 :
       String memberld = "hellold";
       Member member = jpa.find (Member. class,memberld) ; //조회
       find() 메소드는 객체 하나를 데이터베이스에서 조회해준다. JPA는 객체와 매핑정보를 보고 SELECT SQL을 생성 후, 데이터베이스에 전달, 그 결과로 Member 객체를 생성해서 반환한다.
    3. 수정 기능 :
       Member member = jpa. find (Member. classr memberld);
       member. setName ( H이름변경” ) //수정
       JPA는 별도의 수정을 지원하지않고, 대신에 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 데이터베이스에 UPDATE SQL이 전달되는 구조이다. 따라서 간단하게 수정 기능을 수행할 수 있다
    4. 연관된 객체 조회 :
       Member member = jpa.find (Member. class, memberld) ;
       Team team = member.getTeam () ; //연관된 객체 조회
       JPA는 연관된 객체를 사용하는 시점에 SELECT SQL을 실행한다. 따라서 연관된 객체 조회가 편리해진다
5. 패러다임의 불일치 : 위에서 말했던 객체지향에서 말하는 장점과 관계형 데이터베이스가 가지는 장점이 다르기 때문에, 둘의 기능과 표현 방법 또한 다르다. 이것을 패러다임의 불일치라고 한다

   해결방법 1 : 상속 : 패러다임 불일치의 해결 방법으로 자바컬렉션에 객체를 저장하듯이 JPA에 객체를 저장하는 방법임

    ```java
    abstract class Item {
    Long id;
    String name;
    int price;
    }
    class Album extends Item {
    String artist;
    }
    class Movie extends Item {
    String director;
    String actor;
    }
    ```

   위 객체모델 코드를 예시로 들면,

   Album 객체를 저장하려면 이 객체를 분해해서 다음 두 SQL을 만들어야 한다.
   ```java
   INSERT INTO ITEM ...
   INSERT INTO ALBUM ...
   ```
   Movie 객체도 이런식으로 만들어줘야한다
   ```java
   INSERT INTO ITEM ...
   INSERT INTO MOVIE ...
   ```
   단 JPA에서는 자바 컬렉션에 객체 저장하듯이
   ```java
   jpa.persist(album);
   ```
   이 코드로 pesist 메서드를 활용하여 간단하게 객체를 저장할 수 있다.

   저장한 Album 객체를 조회하고싶다면 위에 설명한 find() 메소드를 사용해서 객체를 조회하면 된다
   ```java
   String albumld = "idlOO";
   Album album = jpa.find (Album, class, albumld);
   ```
   해결방법 2 : 연관관계
   객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된
   객체를 조회한다. 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를
   가지고 조인을 사용해서 연관된 테이블을 조회한다.

    ```java
    member. setTeam (team); //회원과 팀 연관관계 설정
    jpa.persist (member); //회원과 연관관계 함께 저장
    Member member = jpa.find(Member.class, memberId);
    Team team = member.getTeam(); 
    ```

   위 코드를 활용하여 개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하여주고, JPA는 team의 참조를 외래 키로 변환해서 INSERT SQL을 데이터베이스에 전달한다.

6. JPA의 개념 : 자바진영의 ORM 기술 표준을 말하며 애플리케이션과 JDBC 사이에서 동작한다
7. ORM의 개념 : ORM(object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻으로 ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다. 개발자는 INSERT SQL을 직접 작성하지 않아도 객체를 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장해주면 된다.
<hr>

## 3장 영속성 관리

1. 엔티티 매니저 팩토리의 개념 :
   엔티티 매니저를 만드는 공장을 의미하며 공장을 만드는 비용은 상당히 크기 때문에 여러개의 공장을 만드는거보다, 한 개의 엔티티 매니저 팩토리를 만들어서 전체 애플리케이션에서 공유하도록 설계함 따라서 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다는 특징이 있음
2. 엔티티 매너지의 개념 :
   엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유해선 안된다는 특징을 가짐
3. 영속성 컨텍스트의 개념 : 엔티티를 영구 저장하는 환경으로, 엔티티 매니저를 생성할 때 하나가 생성된다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 이를 통해 영속성 컨텍스트를 관리할 수 있다.
4. 엔티티의 4가지 생명주기
    1. 비영속(new/transient)： 영속성 컨텍스트와 전혀 관계가 없는 상태
    2. 영속(managed)： 영속성 컨텍스트에 저장된 상태
    3. 준영속(detached)： 영속성 컨텍스트에 저장되었다가 분리된 상태
    4. 삭제(removed)： 삭제된 상태
5. 영속성 컨텍스트의 특징
    1. 영속성 컨텍스트와 식별자 값

       영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기 때문에 식별자 값이 반드시 있어야한다는 특징이 있다.

    2. 영속성 컨텍스트와 데이터베이스 저장

       영속성 컨텍스트에 엔티티를 저장하면 JPA는 트랜잭션을 커밋하는 순간 즉시 데이터베이스에 반영하는데, 이것을 플러시(flush)라고 한다

    3. 영속성 컨텍스트의 엔티티 관리시 장점

       ■ 1차캐시
       ■ 동일성 보장
       ■ 트랜잭션을 지원하는 쓰기 지연

       ■ 변경 감지

       ■ 지연 로딩

6. flush 모드

   준영속 : 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 의미하는 상태로서 분리된 엔티티는 영속성 컨텍스트의 기능을 사용 불가능

    ```java
    em.detach(entity): //특정 엔티티를 준영속 상태로 전환
    em.clear(): //영속성 컨텍스트를 완전히 초기화
    em.close(): //영속성 컨텍스트를 종료
    ```

    1. detach() : 이 메서드를 호출하여 1차 캐시부터 캐리 저장소까지 해당 엔티티에 관련된 모든 정보 제거하여 준영속 상태로 만든다.
    2. clear() : 영속성 컨텍스트를 초기화하여 모든 엔터티를 준영속 상태로 만든다.
    3. close() : 영속성 컨텐스트를 종료하여 모든 엔터티를 준영속 상태로 만든다.

    ```java
    FlushModeType.AUTO: //commit 또는 쿼리를 실행시 자동으로 flush
    FlushModeType.COMMIT: //commit할때 자동으로 flush
    ```


<hr>